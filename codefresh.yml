# This is the Codefresh pipeline workflow for the Customer Engineering demo projects.
# When executed, it does the following:
# 1) Runs "pulumi up" for the applicable Pulumi project based on the Codefresh project.
#    See the Setup notes at the end of this file for more information.
# 3) Once the pulumi up has completed (or failed), the user is prompted in the Codefresh UI to destroy the given Pulumi stack.
#    If the user select approve, the stack is destroyed.
#    If the user selects deny, the stack is not destroyed.
#    If the user does NOT select either, the stack will be automatically destroyed after an hour.
#
# CI/CD DEMO SET UP INSTRUCTIONS
# See comments at bottom of this file on how to set up Codefresh for this to work.
#

version: '1.0'
stages:
  - prepare
  - deploy
  - promote
  - cleanup
steps:
  # Get Pulumi application from Git
  cloneRepo:
    stage: prepare
    title: Clone Repo
    type: git-clone
    repo: '${{CF_REPO_OWNER}}/${{CF_REPO_NAME}}'
    revision: '${{CF_REVISION}}'
    git: github
  # Prepare the environment
  prepareEnvironment:
    stage: prepare
    title: Prepare Environment
    fail_fast: true
    image: pulumi/pulumi
    shell: bash
    working_directory: ${{CF_VOLUME_PATH}}/${{CF_REPO_NAME}}/${{REPO_DIR}} # Where is the pulumi code for this project found in the repo?
    commands:
      # Set PULUMI_HOME so it uses the volume and not the default ~/.pulumi - this is especially important for K8s since destroys need to find the k8s provider stored in $PULUMI_HOME
      # Be sure to set Codefresh Account Settings/Pipeline Settings to keep build environment for "Pending Approval" state.
      - export PULUMI_HOME=$CF_VOLUME_PATH
      - cf_export PULUMI_HOME

      # Create some environment variables for use in this step and subsequent steps
      # Since we equate CF Project with Pulumi project and CF Pipeline with Pulumi stack, we can build variables used for Pulumi commands.
      # CF_PIPELINE_NAME is of form <CF PROJECT>/<CF PIPELINE> which means it's of form <PULUMI PROJECT>/<PULUMI STACK>
      # A Pulumi full stack name is of the form <PULUMI ORGANIZATION>/<PULUMI PROJECT>/<PULUMI STACK>.
      # Therefore, Pulumi full stack is <PULUMI_ORG>/$CF_PIPELINE_NAME
      # $PULUMI_ORG is an environment variable set up when configuring the Codefresh account (see below).
      - export PULUMI_STACK_PATH=$PULUMI_ORG/$CF_PIPELINE_NAME
      - cf_export PULUMI_STACK_PATH

      # Get the Codefresh Project name.
      # Used for reference later on
      - export CF_PROJECT=`echo $CF_PIPELINE_NAME | cut -d"/" -f1`
      - cf_export CF_PROJECT

      # Set up the base environment
      - npm install

      # In the interest of keeping a single yml for all demos,
      # this logic is used to handle having to set up the k8s cluster folder for k8s demos that leverage the cluster code.
      # For the base cluster demo this code will run unnecessarily, but it allows for more flexibility later if we add other k8s demos.
      - export GOOGLE_APPLICATION_CREDENTIALS=$PWD/google_application_credentials.json
      - echo $GOOGLE_CREDENTIALS > $GOOGLE_APPLICATION_CREDENTIALS
      - cf_export GOOGLE_APPLICATION_CREDENTIALS
      # This modifies gcp.ts to produce a kubeconfig that is compatible with a gcloud-free environment we are using in the Codefresh runner
      # and it sets up node modules for the cluster code.
      - sed -i -e '/ config:/{N;N;N;N;d;}' ./gcp.ts

      # make the codefresh cluster add and remove scripts executable
      - apt-get install -y jq
      - echo "after jq install"
      - which jq
      - echo "after trying to see jq"
      - chmod +x ./codefresh_add_cluster.sh
      - chmod +x ./codefresh_remove_cluster.sh

  # Stand up the stack for this pipeline
  deployStack:
    stage: deploy
    title: Deploy Pulumi Stack
    fail_fast: false
    image: pulumi/pulumi
    working_directory: ${{prepareEnvironment}}
    commands:
      # Select stack
      - pulumi stack select -c $PULUMI_STACK_PATH
      # Deploy/update the stack
      - pulumi up --non-interactive --yes --skip-preview # --debug --logtostderr -v 9

  addCluster:
    stage: deploy
    title: Add K8s Cluster to Codefresh
    fail_fast: false
    image: pulumi/pulumi
    working_directory: ${{prepareEnvironment}}
    commands:
      - export GCP_PROJECT=`pulumi stack output gcpProject`
      - export GKE_CLUSTER_NAME=`pulumi stack output clusterName`
      - ./codefresh_add_cluster.sh

  # Wait for a response to go and clean up the stack.
  # If denied, the stack will remain.
  # If approved, the stack will be destroyed.
  # If no answer given, the stack will be destroyed after an hour.
  waitToClean:
    type: pending-approval
    stage: cleanup
    title: Destroy stack?
    fail_fast: true
    timeout: # force a clean up after "duration" hours.
      duration: 1
      finalState: approved
  # Destroy the staging and production stacks once the clean up question is approved or never answered.
  destroyPulumiStacks:
    stage: cleanup
    title: Destroy Demo Stacks
    fail_fast: false
    image: pulumi/pulumi
    working_directory: ${{prepareEnvironment}}
    commands:
      # Remove the cluster from codefresh dashboard
      - export GCP_PROJECT=`pulumi stack output gcpProject`
      - export GKE_CLUSTER_NAME=`pulumi stack output clusterName`
      - ./codefresh_remove_cluster.sh
      # Destroy the stack
      #### - export PULUMI_STACK_PATH=$PULUMI_ORG/$CF_PIPELINE_NAME
      # When testing a new pipeline to replace an old pipeline, "new-" is put at the beginning of the project name.
      # This next line removes it if it is there so the rest of the references work as expected.
      - export CF_PIPE_NAME=`echo $CF_PIPELINE_NAME | sed 's/new-//g'`
      - export PULUMI_STACK_PATH=$PULUMI_ORG/$CF_PIPE_NAME
      - pulumi stack select $PULUMI_STACK_PATH
      - pulumi destroy -s $PULUMI_STACK_PATH --non-interactive -y --skip-preview
#
#
####### SET UP NOTES ######
# The following notes explain how to set things up in Codefresh.io
# NOTE, the mapping of Codefresh constructs and Pulumi constructs are as follows:
# - Codefresh Project is mapped to Pulumi Project
# - Codefresh Pipeline is mapped to Pulumi Stack.
# Therefore, the project and pipeline names in Codefresh need to match those being used in Pulumi.
# There is Pulumi service account for staging pipelines and a different Pulumi service account for productin pipelines.
#
# Account Settings -> Pipeline Settings
# - Advanced options - change to keep the volume on approval (build remains active)
# Account Settings -> Shared Configuration
# - Create a shared secret configuration context for the Cloud Credentials and store the required environment variables:
#   - AWS_ACCESS_KEY_ID (see https://www.pulumi.com/docs/intro/cloud-providers/aws/setup/#environment-variables)
#   - AWS_SECRET_ACCESS_KEY
#   - ARM_CLIENT_ID (see https://www.pulumi.com/docs/intro/cloud-providers/azure/setup/#service-principal-authentication)
#   - ARM_CLIENT_SECRET
#   - ARM_TENANT_ID
#   - ARM_SUBSCRIPTION_ID
#   - GOOGLE_CREDENTIALS (see https://www.pulumi.com/docs/intro/cloud-providers/gcp/service-account/)
# - There are two pipelines/stacks - Staging and Prod - they have their own PULUMI_ACCESS_TOKEN defined for them.
#   So create two shared secret configuration contexts - one for each pipelinei/stack which.
#   Both contexts define the same environment variable, PULUMI_ACCESS_TOKEN and then the applicable context will be used
#   when creating the pipelines below.
#   - PULUMI_ACCESS_TOKEN (see https://www.pulumi.com/docs/intro/console/accounts-and-organizations/accounts/#access-tokens)
# - Create a shared (nonsecret) configuration context for Pulumi Configuration and store the required environment variable:
#   - PULUMI_ORG contains the name of the Pulumi Organization underwhich the stacks will be managed. The PULUMI_ACCESS_TOKEN must have write access to this Pulumi organization.

# For each demo in the repo you want to integrate CI/CD into, do the following:
# - Create a Codefresh project with the same name as the corresponding Pulumi project.
#   For example, demo, aws-ts-webserver is deployed in project demo-aws-ts-webserver.
#   This is the name to use for the Codefresh project.
# - Set Project Variables as follows:
#   - REPO_DIR = the path to the given demo this project is for. For example, demos/aws-ts-webserver.

# For each Codefresh project, do the following:
# - Create a pipeline named "staging"
#   - Associate it with the customer-engineering repo (i.e. the repo where the demos are stored).
#   - Select the Workflow view
#   - Click the Triggers tab on the righthand of the screen in the Workflow view
#     - In the "BRANCH" section enter: /^((?!master).)*$/g
#       This matches any branch that is not "master".
#     - In the "MODIFIED FILES" section enter: <VALUE USED FOR REPO_DIR ABOVE>/** (e.g. demos/aws-ts-webserver/**)
#       Note the two asterisks.
#       This will cause the pipeline to trigger due to a commit of a change that affects the given repo directory.
#   - Click the Variables tab on the righthand of the screen in the Workflow view.
#     - Click the gear (DO NOT CLICK ADD VARIABLE).
#       - Click IMPORT FROM SHARED CONFIGURATION and select the Cloud Credentials and Pulumi Organization contexts created above,
#         and the STAGING Pulumi Access Token configuration created above.
#   - Once back to the Workflow view, change the "Inline YAML" selection to "Use YAML from Repository" and specify the path to the codefresh.yml file (i.e. this file).
#   - Make sure the github folder for the given demo (e.g. aws-ts-webserver) has a Pulumi.staging.yaml file in it. If not, create one based on the Pulumi.dev.yaml file or from scratch.
# - Create a a pipeline named "prod" similar to the staging pipeline:
#   - Git trigger:
#     - In the "BRANCH" section enter: /^((master)$).*/g
#       This way this pipeline only runs when a change is commited to the master branch.
#     - In the "MODIFIED FILES" section enter: <VALUE USED FOR REPO_DIR ABOVE>/** (e.g. demos/aws-ts-webserver/**)
#       Note the two asterisks.
#       This will cause the pipeline to trigger due to a commit of a change that affects the given repo directory.
#   - Variables:
#     - Click the gear (DO NOT CLICK ADD VARIABLE).
#       - Click IMPORT FROM SHARED CONFIGURATION and select the Cloud Credentials and Pulumi Organization contexts created above,
#         and the PRODUCTION Pulumi Access Token configuration created above.
#   - Once back to the Workflow view, change the "Inline YAML" selection to "Use YAML from Repository" and specify the path to the codefresh.yml file (i.e. this file).
#   - Make sure the github folder for the given demo (e.g. aws-ts-webserver) has a Pulumi.prod.yaml file in it. If not, create one based on the Pulumi.dev.yaml file or from scratch.
#
# See notes in other codefresh yamls found in this folder for setting up additional pipelines such as for pull request checks and periodic testing.

